{"version":3,"sources":["slices/appSlice.js","utils/utils.js","hooks/useGetCryptoData.js","components/BearTrendButton.js","components/DataChart.js","components/DateRangeInput.js","components/HighestTradVolButton.js","components/TimeMachineMaxProfitButton.js","app/store.js","App.js","index.js"],"names":["appSlice","createSlice","name","initialState","cryptoPriceRangeData","resultStartEndDates","startDate","date","text","endDate","prevApiCallUrl","sma","is24HourInterval","currentAnalysis","reducers","setCryptoPriceRangeData","state","action","payload","setResultStartEndDates","setPrevApiCallUrl","setStartDate","setEndDate","setSMA","setIs24HourInterval","setCurrentAnalysis","actions","convDateToUTCUnix","normHours","getHours","utcHours","getUTCHours","diff","hoursToSubstract","getTime","hoursToAdd","formatUTCTimeString","Date","getUTCMonth","getUTCDate","getUTCFullYear","getUTCMinutes","convertPriceIntervalToDay","arr","filter","obj","i","getIs24HourInterval","prices","startCount","countDone","dataPointsBetweenDays","index","length","price","curPriceTimeObj","prevPriceTimeObj","useCryptoPriceRangeInfo","dispatch","useDispatch","useSelector","app","startDate1","endDate1","JSON","parse","getCryptoPriceRangeInfo","a","startDateObject","moment","format","endDateObject","startDateUnix","endDateUnix","url","data","axios","get","res","getCloserToMidNightPrice","checkCurrentTrend","priceMidNight","prevDayPrice","currentBearTrend","longestBearTrend","trend","console","log","curBearTrend","curLongestBearTrend","BearTrendButton","setResult","ToggleButton","selected","value","onClick","then","response","checkTrend","undefined","ChartJS","register","registerables","DataChart","cryptoData","useState","smaDataPrices","setSmaDataPrices","labels","map","getMonth","getDate","getFullYear","arrayJoinIndex","setArrayJoinIndex","lastArrayJoinIndex","setLastArrayJoinIndex","useEffect","smaStarturl","smaEndurl","resStart","resEnd","newPrices","slice","startPrices","endPrices","unshift","push","flat","findIndex","p","datasets","type","label","borderColor","backgroundColor","borderWidth","pointRadius","price1","reduce","prev","curr","e","fill","options","responsive","DateRangeInput","className","LocalizationProvider","dateAdapter","AdapterDateFns","DatePicker","onChange","newValue","stringify","renderInput","params","TextField","HighestTradVolButton","setData","total_volumes","curHighestVol","curHighestVolDate","forEach","dateVol","highestVolume","highestVolumeDate","getHighestVolume","highestVolDate","TimeMachineMaxProfitButton","moreThanPrev","priceOnlyDeclines","lowestPriceDate","lowestPrice","getLowestPrice","highestPriceDate","highestPrice","getHighestPrice","highestPriceDateObj","lowestPriceDateObj","lowestBeforeHighestDate","lowestBeforeHighest","getLowestBeforeHighest","highestAfterLowestDate","highestAfterLowest","reverse","getHighestAfterLowest","profit1","profit2","lowestBeforeHighestDateObj","highestAfterLowestDateObj","store","configureStore","reducer","appReducer","App","result","getState","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.41f835a8.chunk.js","sourcesContent":["import { createSlice } from \"@reduxjs/toolkit\";\r\n\r\nconst initialState = {\r\n  cryptoPriceRangeData: [],\r\n  resultStartEndDates: {\r\n    startDate: { date: null, text: \"\" },\r\n    endDate: { date: null, text: \"\" },\r\n  },\r\n  prevApiCallUrl: \"\",\r\n  sma: 50,\r\n  startDate: null,\r\n  endDate: null,\r\n  is24HourInterval: false,\r\n  currentAnalysis: null,\r\n};\r\n\r\nexport const appSlice = createSlice({\r\n  name: \"app\",\r\n  initialState,\r\n  reducers: {\r\n    setCryptoPriceRangeData: (state, action) => {\r\n      state.cryptoPriceRangeData = action.payload;\r\n    },\r\n    setResultStartEndDates: (state, action) => {\r\n      state.resultStartEndDates = action.payload;\r\n    },\r\n    setPrevApiCallUrl: (state, action) => {\r\n      state.prevApiCallUrl = action.payload;\r\n    },\r\n    setStartDate: (state, action) => {\r\n      state.startDate = action.payload;\r\n    },\r\n    setEndDate: (state, action) => {\r\n      state.endDate = action.payload;\r\n    },\r\n    setSMA: (state, action) => {\r\n      state.sma = action.payload;\r\n    },\r\n    setIs24HourInterval: (state, action) => {\r\n      state.is24HourInterval = action.payload;\r\n    },\r\n    setCurrentAnalysis: (state, action) => {\r\n      state.currentAnalysis = action.payload;\r\n    },\r\n  },\r\n});\r\n\r\nexport const {\r\n  setCryptoPriceRangeData,\r\n  setResultStartEndDates,\r\n  setPrevApiCallUrl,\r\n  setStartDate,\r\n  setEndDate,\r\n  setSMA,\r\n  setIs24HourInterval,\r\n  setCurrentAnalysis,\r\n} = appSlice.actions;\r\n\r\n// Selectors - This is how we pull information from the Global store slice\r\n//export const selectItems = (state) => state.basket.items;\r\n\r\nexport default appSlice.reducer;\r\n","export const convDateToUTCUnix = (date) => {\r\n  const normHours = date.getHours();\r\n  const utcHours = date.getUTCHours();\r\n\r\n  const diff = normHours - utcHours;\r\n  if (utcHours > normHours) {\r\n    if (diff < -12.1) {\r\n      // time offset is positive\r\n      const hoursToSubstract = 3600000 * (24 + diff);\r\n\r\n      return date.getTime() - hoursToSubstract;\r\n    }\r\n    return date.getTime() + 3600000 * (utcHours - normHours); // offset is negative\r\n  }\r\n  if (utcHours < normHours) {\r\n    if (diff > 14.1) {\r\n      // time offset is negative\r\n\r\n      const hoursToAdd = 3600000 * (24 - diff);\r\n      return date.getTime() + hoursToAdd;\r\n    }\r\n    return date.getTime() + 3600000 * (utcHours - normHours); // offset is positive\r\n  }\r\n  return date.getTime();\r\n};\r\n\r\nexport const formatUTCTimeString = (date) => {\r\n  // give date in unix\r\n  date = new Date(date);\r\n  var UTCTimeString =\r\n    \"\" +\r\n    (date.getUTCMonth() + 1) +\r\n    \".\" +\r\n    (date.getUTCDate() + 1) +\r\n    \".\" +\r\n    date.getUTCFullYear() +\r\n    \"   \" +\r\n    (date.getUTCHours() < 10 ? \"0\" + date.getUTCHours() : date.getUTCHours()) +\r\n    \":\" +\r\n    (date.getUTCMinutes() < 10\r\n      ? \"0\" + date.getUTCMinutes()\r\n      : date.getUTCMinutes()) +\r\n    \"  UTC\";\r\n\r\n  return UTCTimeString;\r\n};\r\n\r\nexport const convertPriceIntervalToDay = (arr) => {\r\n  const newArr = arr?.filter((obj, i) => {\r\n    const date = new Date(obj?.[0]);\r\n    const prevDate = new Date(arr?.[i - 1]?.[0]);\r\n    return prevDate.getUTCDate() !== date.getUTCDate();\r\n  });\r\n  return newArr;\r\n};\r\n\r\nexport const getIs24HourInterval = (prices) => {\r\n  let startCount = false;\r\n  let countDone = false;\r\n  let dataPointsBetweenDays = 0;\r\n  for (let index = 0; index < prices?.length; index++) {\r\n    const price = prices[index];\r\n\r\n    if (index === 0) {\r\n      continue;\r\n    }\r\n\r\n    var curPriceTimeObj = new Date(price[0]);\r\n    var prevPriceTimeObj = new Date(prices[index - 1][0]);\r\n\r\n    if (curPriceTimeObj.getUTCDate() !== prevPriceTimeObj.getUTCDate()) {\r\n      if (startCount) {\r\n        countDone = true;\r\n        break;\r\n      }\r\n      startCount = true;\r\n    }\r\n    if (startCount === true && countDone === false) {\r\n      dataPointsBetweenDays++;\r\n    }\r\n  }\r\n  return dataPointsBetweenDays < 20;\r\n};\r\n","import axios from \"axios\";\r\nimport moment from \"moment\";\r\nimport { useDispatch } from \"react-redux\";\r\nimport { useSelector } from \"react-redux\";\r\nimport {\r\n  setCryptoPriceRangeData,\r\n  setIs24HourInterval,\r\n  setPrevApiCallUrl,\r\n} from \"../slices/appSlice\";\r\nimport { convDateToUTCUnix, getIs24HourInterval } from \"../utils/utils\";\r\n\r\n//gets btc price, 24 volume and market cap info for a date range\r\n//time interval between info objects is 1h or 24h depending on date range\r\nconst useCryptoPriceRangeInfo = () => {\r\n  const dispatch = useDispatch();\r\n  // startDate & endDate are required to be in unix milliseconds\r\n\r\n  const prevApiCallUrl = useSelector((state) => state.app.prevApiCallUrl);\r\n  const cryptoPriceRangeData = useSelector(\r\n    (state) => state.app.cryptoPriceRangeData\r\n  );\r\n  const startDate1 = useSelector((state) => state.app.startDate);\r\n  const endDate1 = useSelector((state) => state.app.endDate);\r\n  const startDate = JSON.parse(startDate1);\r\n  const endDate = JSON.parse(endDate1);\r\n\r\n  const getCryptoPriceRangeInfo = async () => {\r\n    const startDateObject = new Date(\r\n      moment(startDate).format(\"YYYY-MM-DD\") + \"T00:00:00\"\r\n    );\r\n    const endDateObject = new Date(\r\n      moment(endDate).format(\"YYYY-MM-DD\") + \"T00:00:00\"\r\n    );\r\n\r\n    const startDateUnix = convDateToUTCUnix(startDateObject) - 3600000;\r\n    const endDateUnix = convDateToUTCUnix(endDateObject) + 3600000;\r\n\r\n    const url = `https://api.coingecko.com/api/v3/coins/bitcoin/market_chart/range?vs_currency=eur&from=${\r\n      startDateUnix / 1000\r\n    }&to=${endDateUnix / 1000}`;\r\n    if (url === prevApiCallUrl) {\r\n      return { data: cryptoPriceRangeData };\r\n    } else {\r\n      let res = await axios.get(url);\r\n      dispatch(setIs24HourInterval(getIs24HourInterval(res.data.prices)));\r\n      dispatch(setCryptoPriceRangeData(res.data));\r\n\r\n      dispatch(setPrevApiCallUrl(url));\r\n\r\n      return { data: res.data };\r\n    }\r\n  };\r\n  return [getCryptoPriceRangeInfo];\r\n};\r\n\r\nexport default useCryptoPriceRangeInfo;\r\n\r\n/* \r\nconst startDate1 = useSelector((state) => state.app.startDate);\r\nconst endDate1 = useSelector((state) => state.app.endDate);\r\nconst startDate = new Date(JSON.parse(startDate1));\r\nconst endDate = new Date(JSON.parse(endDate1));\r\nstartDate.getTime() \r\nendDate.getTime() */\r\n","import React from \"react\";\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\nimport useCryptoPriceRangeInfo from \"../hooks/useGetCryptoData\";\r\nimport {\r\n  setCryptoPriceRangeData,\r\n  setCurrentAnalysis,\r\n  setResultStartEndDates,\r\n} from \"../slices/appSlice\";\r\nimport { convDateToUTCUnix } from \"../utils/utils\";\r\n\r\nimport ToggleButton from \"@mui/material/ToggleButton\";\r\nimport moment from \"moment\";\r\n\r\nconst getCloserToMidNightPrice = (\r\n  prevPriceTimeObj,\r\n  curPriceTimeObj,\r\n  prices,\r\n  index\r\n) => {\r\n  const curPriceMinutesToMidNight =\r\n    curPriceTimeObj.getUTCHours() * 60 + curPriceTimeObj.getUTCMinutes();\r\n  const prevPriceMinutesToMidNight =\r\n    (23 - prevPriceTimeObj.getUTCHours()) * 60 +\r\n    (60 - prevPriceTimeObj.getUTCMinutes());\r\n  if (curPriceMinutesToMidNight < prevPriceMinutesToMidNight) {\r\n    return prices[index];\r\n  } else {\r\n    return prices[index - 1];\r\n  }\r\n};\r\n\r\nconst checkCurrentTrend = (\r\n  priceMidNight,\r\n  prevDayPrice,\r\n  currentBearTrend,\r\n  longestBearTrend\r\n) => {\r\n  if (priceMidNight[1] >= prevDayPrice?.[1] && prevDayPrice) {\r\n    currentBearTrend = { trend: 0, startDate: priceMidNight[0] };\r\n  } else if (priceMidNight[1] < prevDayPrice?.[1] && prevDayPrice) {\r\n    currentBearTrend.trend++;\r\n    currentBearTrend.endDate = priceMidNight[0];\r\n    if (longestBearTrend.trend < currentBearTrend.trend) {\r\n      console.log(currentBearTrend);\r\n      longestBearTrend = currentBearTrend;\r\n    }\r\n  }\r\n\r\n  return {\r\n    curBearTrend: currentBearTrend,\r\n    curLongestBearTrend: longestBearTrend,\r\n  };\r\n};\r\n\r\n// component that gets the longest bear trend between startDate and endDate\r\nconst BearTrendButton = ({ setResult }) => {\r\n  const is24HourInterval = useSelector((state) => state.app.is24HourInterval);\r\n  const currentAnalysis = useSelector((state) => state.app.currentAnalysis);\r\n  const dispatch = useDispatch();\r\n  const [getCryptoPriceRangeInfo] = useCryptoPriceRangeInfo();\r\n\r\n  const handleBearTrendClick = () => {\r\n    var longestBearTrend = { trend: 0, startDate: null, endDate: null };\r\n    dispatch(setCurrentAnalysis(1));\r\n    getCryptoPriceRangeInfo()\r\n      .then((response) => {\r\n        console.log(response);\r\n        const prices = response.data.prices;\r\n\r\n        console.log(\"is 24h interval   \", response.data);\r\n\r\n        var currentBearTrend = { trend: 0 };\r\n\r\n        var currentBearTrendStartDate;\r\n        var prevDayPrice = null;\r\n        var priceMidNight = null;\r\n        var checkTrend = false;\r\n        console.log(prices);\r\n\r\n        for (let index = 0; index < prices?.length; index++) {\r\n          const price = prices[index];\r\n\r\n          var curPriceTimeObj = new Date(price[0]);\r\n          var prevPriceTimeObj =\r\n            index === 0 ? null : new Date(prices[index - 1][0]);\r\n          if (\r\n            prices[index + 1] === undefined &&\r\n            curPriceTimeObj.getUTCHours() > 22\r\n          ) {\r\n            priceMidNight = price;\r\n            checkTrend = true;\r\n          } else {\r\n            if (is24HourInterval === false) {\r\n              if (index === 0) {\r\n                continue;\r\n              }\r\n              if (\r\n                curPriceTimeObj.getUTCDate() !== prevPriceTimeObj.getUTCDate()\r\n              ) {\r\n                priceMidNight = getCloserToMidNightPrice(\r\n                  prevPriceTimeObj,\r\n                  curPriceTimeObj,\r\n                  prices,\r\n                  index\r\n                );\r\n                checkTrend = true;\r\n              }\r\n            } else if (is24HourInterval === true) {\r\n              priceMidNight = price;\r\n              checkTrend = true;\r\n            }\r\n          }\r\n          if (priceMidNight && !currentBearTrend.startDate) {\r\n            currentBearTrend.startDate = priceMidNight[0];\r\n          }\r\n          if (checkTrend === true) {\r\n            const { curLongestBearTrend, curBearTrend } = checkCurrentTrend(\r\n              priceMidNight,\r\n              prevDayPrice,\r\n              currentBearTrend,\r\n              longestBearTrend\r\n            );\r\n            currentBearTrend = curBearTrend;\r\n            longestBearTrend = curLongestBearTrend;\r\n\r\n            prevDayPrice = priceMidNight;\r\n            checkTrend = false;\r\n          }\r\n        }\r\n      })\r\n      .then(() => {\r\n        console.log(longestBearTrend);\r\n        dispatch(\r\n          setResultStartEndDates({\r\n            startDate: {\r\n              date: longestBearTrend.startDate,\r\n              text: \"Longest bear trend start\",\r\n            },\r\n            endDate: {\r\n              date: longestBearTrend.endDate,\r\n              text: \"Longest bear trend end\",\r\n            },\r\n          })\r\n        );\r\n        setResult(\r\n          \"Longest bear trend in given date range is \" +\r\n            longestBearTrend.trend +\r\n            \" days\"\r\n        );\r\n      });\r\n  };\r\n\r\n  return (\r\n    <ToggleButton\r\n      selected={currentAnalysis === 1 ? true : false}\r\n      value=\"bearTrend\"\r\n      onClick={handleBearTrendClick}\r\n    >\r\n      Longest Bear trend\r\n    </ToggleButton>\r\n  );\r\n};\r\n\r\nexport default BearTrendButton;\r\n","import axios from \"axios\";\r\nimport { Chart as ChartJS, registerables } from \"chart.js\";\r\nimport { useEffect, useState } from \"react\";\r\nimport { Chart } from \"react-chartjs-2\";\r\nimport { useSelector } from \"react-redux\";\r\nimport { convertPriceIntervalToDay } from \"../utils/utils\";\r\n\r\nChartJS.register(...registerables);\r\n\r\nfunction DataChart({}) {\r\n  const startDate1 = useSelector((state) => state.app.startDate);\r\n  const endDate1 = useSelector((state) => state.app.endDate);\r\n  const startDate = new Date(JSON.parse(startDate1));\r\n  const endDate = new Date(JSON.parse(endDate1));\r\n  const resultStartEndDates = useSelector(\r\n    (state) => state.app.resultStartEndDates\r\n  );\r\n  const cryptoData = useSelector((state) => state.app.cryptoPriceRangeData);\r\n  const prevApiCallUrl = useSelector((state) => state.app.prevApiCallUrl);\r\n  const is24HourInterval = useSelector((state) => state.app.is24HourInterval);\r\n  const [smaDataPrices, setSmaDataPrices] = useState(null);\r\n\r\n  const labels = cryptoData?.prices?.map(\r\n    (price) =>\r\n      \"\" +\r\n      (new Date(price[0]).getMonth() + 1) +\r\n      \"/\" +\r\n      (new Date(price[0]).getDate() + 1) +\r\n      \"/\" +\r\n      new Date(price[0]).getFullYear()\r\n  );\r\n  const [arrayJoinIndex, setArrayJoinIndex] = useState(null);\r\n  const [lastArrayJoinIndex, setLastArrayJoinIndex] = useState(null);\r\n  useEffect(async () => {\r\n    try {\r\n      const smaStarturl = `https://api.coingecko.com/api/v3/coins/bitcoin/market_chart/range?vs_currency=eur&from=${\r\n        startDate.getTime() / 1000 - 1728000\r\n      }&to=${startDate.getTime() / 1000}`;\r\n      const smaEndurl = `https://api.coingecko.com/api/v3/coins/bitcoin/market_chart/range?vs_currency=eur&from=${\r\n        endDate.getTime() / 1000\r\n      }&to=${endDate.getTime() / 1000 + 1728000}`;\r\n\r\n      const resStart = await axios.get(smaStarturl);\r\n\r\n      const resEnd = await axios.get(smaEndurl);\r\n\r\n      let newPrices = [cryptoData?.prices?.slice()];\r\n      let startPrices = resStart.data.prices;\r\n      let endPrices = resEnd.data.prices;\r\n\r\n      if (is24HourInterval) {\r\n        startPrices = convertPriceIntervalToDay(startPrices);\r\n        endPrices = convertPriceIntervalToDay(endPrices);\r\n      }\r\n\r\n      setArrayJoinIndex(startPrices.length - 1);\r\n\r\n      setLastArrayJoinIndex(startPrices.length + newPrices.length - 2);\r\n\r\n      newPrices?.unshift(startPrices);\r\n      newPrices?.push(endPrices);\r\n\r\n      newPrices = newPrices.flat();\r\n\r\n      newPrices?.findIndex((p) => {\r\n        if (p?.[0] === cryptoData?.prices?.[0]?.[0]) {\r\n          return true;\r\n        }\r\n      });\r\n\r\n      //  setSmaData(newPrices);\r\n\r\n      setSmaDataPrices(newPrices.map((price) => price[1]));\r\n    } catch (e) {\r\n      console.log(e);\r\n    }\r\n  }, [prevApiCallUrl]);\r\n\r\n  const data = {\r\n    labels,\r\n    datasets: [\r\n      {\r\n        type: \"line\",\r\n        label: \"price €\",\r\n        borderColor: \"blue\",\r\n        backgroundColor: \"blue\",\r\n\r\n        borderWidth: 2,\r\n        data: cryptoData?.prices?.map((price) => price[1]),\r\n        pointRadius: 0,\r\n      },\r\n\r\n      {\r\n        type: \"line\",\r\n        label: \"sma (20)\",\r\n        borderColor: \"black\",\r\n        backgroundColor: \"black\",\r\n\r\n        borderWidth: 2,\r\n        data: cryptoData?.prices?.map((price1, i) => {\r\n          try {\r\n            if (\r\n              smaDataPrices[arrayJoinIndex + i - lastArrayJoinIndex] &&\r\n              smaDataPrices[arrayJoinIndex + i + lastArrayJoinIndex] &&\r\n              smaDataPrices\r\n            ) {\r\n              const subArray = smaDataPrices?.slice(\r\n                i,\r\n                arrayJoinIndex + i + lastArrayJoinIndex\r\n              );\r\n              const average =\r\n                subArray.reduce((prev, curr) => prev + curr) /\r\n                (lastArrayJoinIndex * 2);\r\n              return average || null;\r\n            } else return null;\r\n          } catch (e) {\r\n            return null;\r\n          }\r\n        }),\r\n        pointRadius: 0,\r\n      },\r\n      {\r\n        type: \"line\",\r\n        label: resultStartEndDates.startDate.text,\r\n        borderColor: \"red\",\r\n        backgroundColor: \"red\",\r\n\r\n        borderWidth: 1,\r\n        data: cryptoData?.prices?.map((price, i) => {\r\n          if (resultStartEndDates.startDate.date === price[0]) {\r\n            return price[1];\r\n          }\r\n        }),\r\n        pointRadius: 10,\r\n        fill: true,\r\n      },\r\n      {\r\n        type: \"line\",\r\n        label: resultStartEndDates?.endDate?.text,\r\n        borderColor: \"red\",\r\n        backgroundColor: \"red\",\r\n\r\n        borderWidth: 1,\r\n        data: cryptoData?.prices?.map((price, i) => {\r\n          if (resultStartEndDates?.endDate?.date === price[0]) {\r\n            return price[1];\r\n          }\r\n        }),\r\n        pointRadius: 10,\r\n      },\r\n    ],\r\n    options: {\r\n      responsive: true,\r\n    },\r\n  };\r\n\r\n  return <Chart type=\"bar\" data={data} />;\r\n}\r\n\r\nexport default DataChart;\r\n","import React from \"react\";\r\nimport TextField from \"@mui/material/TextField\";\r\nimport AdapterDateFns from \"@mui/lab/AdapterDateFns\";\r\nimport LocalizationProvider from \"@mui/lab/LocalizationProvider\";\r\nimport DatePicker from \"@mui/lab/DatePicker\";\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\nimport { setStartDate, setEndDate } from \"../slices/appSlice\";\r\n\r\nconst DateRangeInput = ({}) => {\r\n  const startDate1 = useSelector((state) => state.app.startDate);\r\n  const endDate1 = useSelector((state) => state.app.endDate);\r\n  const startDate = JSON.parse(startDate1);\r\n  const endDate = JSON.parse(endDate1);\r\n\r\n  const dispatch = useDispatch();\r\n\r\n  return (\r\n    <div className=\"\">\r\n      <LocalizationProvider dateAdapter={AdapterDateFns}>\r\n        <DatePicker\r\n          label=\"Start Date\"\r\n          value={startDate}\r\n          onChange={(newValue) => {\r\n            dispatch(setStartDate(JSON.stringify(newValue)));\r\n          }}\r\n          renderInput={(params) => <TextField {...params} />}\r\n        />\r\n        <DatePicker\r\n          label=\"End Date\"\r\n          value={endDate}\r\n          onChange={(newValue) => {\r\n            dispatch(setEndDate(JSON.stringify(newValue)));\r\n          }}\r\n          renderInput={(params) => <TextField {...params} />}\r\n        />\r\n      </LocalizationProvider>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default DateRangeInput;\r\n","import { ToggleButton } from \"@mui/material\";\r\nimport moment from \"moment\";\r\nimport React from \"react\";\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\nimport useCryptoPriceRangeInfo from \"../hooks/useGetCryptoData\";\r\nimport {\r\n  setCryptoPriceRangeData,\r\n  setCurrentAnalysis,\r\n  setResultStartEndDates,\r\n} from \"../slices/appSlice\";\r\nimport { formatUTCTimeString, convDateToUTCUnix } from \"../utils/utils\";\r\n\r\nconst getHighestVolume = (total_volumes) => {\r\n  var curHighestVol = 0;\r\n  var curHighestVolDate = null;\r\n  total_volumes?.forEach((dateVol) => {\r\n    if (dateVol[1] > curHighestVol) {\r\n      curHighestVol = dateVol[1];\r\n      curHighestVolDate = dateVol[0];\r\n    }\r\n  });\r\n  return { highestVolume: curHighestVol, highestVolumeDate: curHighestVolDate };\r\n};\r\n\r\n//component that gets the highest 24h trading volume between startDate and endDate\r\nconst HighestTradVolButton = ({ setResult, setData }) => {\r\n  const currentAnalysis = useSelector((state) => state.app.currentAnalysis);\r\n  const startDate1 = useSelector((state) => state.app.startDate);\r\n  const endDate1 = useSelector((state) => state.app.endDate);\r\n  const startDate = JSON.parse(startDate1);\r\n  const endDate = JSON.parse(endDate1);\r\n\r\n  const dispatch = useDispatch();\r\n  const [getCryptoPriceRangeInfo] = useCryptoPriceRangeInfo();\r\n\r\n  const handleHighTradingVolClick = () => {\r\n    dispatch(setCurrentAnalysis(2));\r\n\r\n    const startDateObject = new Date(\r\n      moment(startDate).format(\"YYYY-MM-DD\") + \"T00:00:00\"\r\n    );\r\n    const endDateObject = new Date(\r\n      moment(endDate).format(\"YYYY-MM-DD\") + \"T00:00:00\"\r\n    );\r\n    const startDateUnix = convDateToUTCUnix(startDateObject) - 3600000;\r\n    const endDateUnix = convDateToUTCUnix(endDateObject) + 3600000;\r\n    getCryptoPriceRangeInfo(startDateUnix, endDateUnix).then((response) => {\r\n      const { highestVolume, highestVolumeDate } = getHighestVolume(\r\n        response.data.total_volumes\r\n      );\r\n\r\n      const highestVolDate = new Date(highestVolumeDate);\r\n      dispatch(\r\n        setResultStartEndDates({\r\n          startDate: { date: highestVolDate.getTime(), text: \"Highest volume\" },\r\n        })\r\n      );\r\n      setResult(\r\n        \"Highest 24h volume in given date range is \" +\r\n          highestVolume +\r\n          \"€ at date: \" +\r\n          formatUTCTimeString(highestVolDate.getTime())\r\n      );\r\n    });\r\n  };\r\n\r\n  return (\r\n    <ToggleButton\r\n      selected={currentAnalysis === 2 ? true : false}\r\n      value=\"HighestTradingVol\"\r\n      onClick={handleHighTradingVolClick}\r\n    >\r\n      Highest trading volume\r\n    </ToggleButton>\r\n  );\r\n};\r\n\r\nexport default HighestTradVolButton;\r\n","import { ToggleButton } from \"@mui/material\";\r\nimport moment from \"moment\";\r\nimport React from \"react\";\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\nimport useCryptoPriceRangeInfo from \"../hooks/useGetCryptoData\";\r\nimport {\r\n  setCryptoPriceRangeData,\r\n  setCurrentAnalysis,\r\n  setResultStartEndDates,\r\n} from \"../slices/appSlice\";\r\nimport { convDateToUTCUnix, formatUTCTimeString } from \"../utils/utils\";\r\n\r\nconst priceOnlyDeclines = (prices) => {\r\n  let moreThanPrev = false;\r\n\r\n  prices?.forEach((price, index, prices) => {\r\n    if (index === 0) {\r\n      return;\r\n    }\r\n    if (price[1] > prices[index - 1][1]) {\r\n      moreThanPrev = true;\r\n    }\r\n  });\r\n  return !moreThanPrev;\r\n};\r\n\r\nconst getLowestPrice = (prices) => {\r\n  let lowestPrice = 999999999999999999;\r\n  let lowestPriceDate;\r\n  prices.forEach((price, index, prices) => {\r\n    if (price[1] < lowestPrice) {\r\n      lowestPrice = price[1];\r\n      lowestPriceDate = price[0];\r\n    }\r\n  });\r\n\r\n  return { lowestPrice, lowestPriceDate };\r\n};\r\nconst getHighestPrice = (prices) => {\r\n  let highestPrice = 0;\r\n  let highestPriceDate;\r\n  prices.forEach((price, index, prices) => {\r\n    if (price[1] > highestPrice) {\r\n      highestPrice = price[1];\r\n      highestPriceDate = price[0];\r\n    }\r\n  });\r\n\r\n  return { highestPrice, highestPriceDate };\r\n};\r\n\r\nconst getLowestBeforeHighest = (prices, highestPriceDate) => {\r\n  let lowestBeforeHighest = 99999999999999999999;\r\n  let lowestBeforeHighestDate;\r\n  prices.forEach((price) => {\r\n    if (price[0] >= highestPriceDate) {\r\n      return;\r\n    }\r\n    if (lowestBeforeHighest > price[1]) {\r\n      lowestBeforeHighest = price[1];\r\n      lowestBeforeHighestDate = price[0];\r\n    }\r\n  });\r\n  return { lowestBeforeHighest, lowestBeforeHighestDate };\r\n};\r\n\r\nconst getHighestAfterLowest = (prices, lowestPriceDate) => {\r\n  let highestAfterLowest = 0;\r\n  let highestAfterLowestDate;\r\n  const prices1 = [...prices];\r\n  const pricesReversed = prices1.reverse();\r\n  pricesReversed.forEach((price) => {\r\n    if (price[0] <= lowestPriceDate) {\r\n      return;\r\n    }\r\n    if (highestAfterLowest < price[1]) {\r\n      highestAfterLowest = price[1];\r\n      highestAfterLowestDate = price[0];\r\n    }\r\n  });\r\n  return { highestAfterLowest, highestAfterLowestDate };\r\n};\r\n\r\n//component that gets the highest profit margin for buying and selling between startDate and endDate\r\nconst TimeMachineMaxProfitButton = ({ setResult, setData }) => {\r\n  const startDate1 = useSelector((state) => state.app.startDate);\r\n  const endDate1 = useSelector((state) => state.app.endDate);\r\n  const startDate = JSON.parse(startDate1);\r\n  const endDate = JSON.parse(endDate1);\r\n  const currentAnalysis = useSelector((state) => state.app.currentAnalysis);\r\n\r\n  const dispatch = useDispatch();\r\n  const [getCryptoPriceRangeInfo] = useCryptoPriceRangeInfo();\r\n\r\n  const handleTimeMachineMaxProfitClick = () => {\r\n    dispatch(setCurrentAnalysis(3));\r\n\r\n    const startDateObject = new Date(\r\n      moment(startDate).format(\"YYYY-MM-DD\") + \"T00:00:00\"\r\n    );\r\n    const endDateObject = new Date(\r\n      moment(endDate).format(\"YYYY-MM-DD\") + \"T00:00:00\"\r\n    );\r\n    const startDateUnix = convDateToUTCUnix(startDateObject) - 3600000;\r\n    const endDateUnix = convDateToUTCUnix(endDateObject) + 3600000;\r\n\r\n    getCryptoPriceRangeInfo(startDateUnix, endDateUnix).then((response) => {\r\n      const prices = response.data.prices;\r\n\r\n      if (priceOnlyDeclines(prices) === true) {\r\n        setResult(\r\n          \"it is not possible to buy & sell for profit in given date range\"\r\n        );\r\n        return;\r\n      }\r\n\r\n      const { lowestPrice, lowestPriceDate } = getLowestPrice(prices);\r\n      const { highestPrice, highestPriceDate } = getHighestPrice(prices);\r\n\r\n      const highestPriceDateObj = new Date(highestPriceDate);\r\n      const lowestPriceDateObj = new Date(lowestPriceDate);\r\n\r\n      if (highestPriceDate > lowestPriceDate) {\r\n        dispatch(\r\n          setResultStartEndDates({\r\n            startDate: {\r\n              date: lowestPriceDateObj.getTime(),\r\n              text: \"Best time to buy\",\r\n            },\r\n            endDate: {\r\n              date: highestPriceDateObj.getTime(),\r\n              text: \"Best time to sell\",\r\n            },\r\n          })\r\n        );\r\n\r\n        setResult(\r\n          \"best time to buy: \" +\r\n            formatUTCTimeString(lowestPriceDateObj.getTime()) +\r\n            \" best time to sell: \" +\r\n            formatUTCTimeString(highestPriceDateObj.getTime())\r\n        );\r\n      } else {\r\n        const { lowestBeforeHighest, lowestBeforeHighestDate } =\r\n          getLowestBeforeHighest(prices, highestPriceDate);\r\n        const { highestAfterLowest, highestAfterLowestDate } =\r\n          getHighestAfterLowest(prices, lowestPriceDate);\r\n        const profit1 = highestPrice - lowestBeforeHighest;\r\n        const profit2 = highestAfterLowest - lowestPrice;\r\n\r\n        const lowestBeforeHighestDateObj = new Date(lowestBeforeHighestDate);\r\n        const highestAfterLowestDateObj = new Date(highestAfterLowestDate);\r\n\r\n        if (profit1 > profit2) {\r\n          dispatch(\r\n            setResultStartEndDates({\r\n              startDate: {\r\n                date: lowestBeforeHighestDateObj.getTime(),\r\n                text: \"Best time to buy\",\r\n              },\r\n              endDate: {\r\n                date: highestPriceDateObj.getTime(),\r\n                text: \"Best time to sell\",\r\n              },\r\n            })\r\n          );\r\n\r\n          setResult(\r\n            \"best time to buy: \" +\r\n              formatUTCTimeString(lowestBeforeHighestDateObj.getTime()) +\r\n              \" best time to sell: \" +\r\n              formatUTCTimeString(highestPriceDateObj.getTime())\r\n          );\r\n        } else if (profit2 > profit1) {\r\n          dispatch(\r\n            setResultStartEndDates({\r\n              startDate: {\r\n                date: lowestPriceDateObj.getTime(),\r\n                text: \"Best time to buy\",\r\n              },\r\n              endDate: {\r\n                date: highestAfterLowestDateObj.getTime(),\r\n                text: \"Best time to sell\",\r\n              },\r\n            })\r\n          );\r\n\r\n          setResult(\r\n            \"best time to buy: \" +\r\n              formatUTCTimeString(lowestPriceDateObj.getTime()) +\r\n              \" best time to sell: \" +\r\n              formatUTCTimeString(highestAfterLowestDateObj.getTime())\r\n          );\r\n        } else {\r\n          setResult(\"no result found for best time to sell and buy\");\r\n        }\r\n      }\r\n    });\r\n  };\r\n\r\n  return (\r\n    <ToggleButton\r\n      selected={currentAnalysis === 3 ? true : false}\r\n      value=\"TimeMachineProfit\"\r\n      onClick={handleTimeMachineMaxProfitClick}\r\n    >\r\n      Time machine max profit\r\n    </ToggleButton>\r\n  );\r\n};\r\n\r\nexport default TimeMachineMaxProfitButton;\r\n","import { configureStore } from \"@reduxjs/toolkit\";\r\nimport appReducer from \"../slices/appSlice\";\r\n\r\nexport const store = configureStore({\r\n  reducer: {\r\n    app: appReducer,\r\n  },\r\n});\r\n","import React, { useEffect, useState } from \"react\";\r\nimport BearTrendButton from \"./components/BearTrendButton\";\r\nimport DataChart from \"./components/DataChart\";\r\nimport DateRangeInput from \"./components/DateRangeInput\";\r\nimport HighestTradVolButton from \"./components/HighestTradVolButton\";\r\nimport TimeMachineMaxProfitButton from \"./components/TimeMachineMaxProfitButton\";\r\nimport { Provider, useSelector } from \"react-redux\";\r\nimport { store } from \"./app/store\";\r\nimport ToggleButtonGroup from \"@mui/material/ToggleButtonGroup\";\r\nimport \"./App.css\";\r\n\r\nfunction App() {\r\n  const [result, setResult] = useState(\"\");\r\n  const cryptoPriceRangeData = store.getState().app.cryptoPriceRangeData;\r\n  const [alignment, setAlignment] = useState(\"TimeMachineProfit\");\r\n  const handleChange = (event, newAlignment) => {\r\n    setAlignment(newAlignment);\r\n  };\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <Provider store={store}>\r\n        <DateRangeInput />\r\n\r\n        <BearTrendButton setResult={setResult} />\r\n        <HighestTradVolButton setResult={setResult} />\r\n        <TimeMachineMaxProfitButton setResult={setResult} />\r\n        <DataChart />\r\n      </Provider>\r\n      <p>{result}</p>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n    <App />,\r\n  document.getElementById('root')\r\n);\r\n\r\n"],"sourceRoot":""}